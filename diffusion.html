<!DOCTYPE html>
<meta charset="utf-8">
<html>
  <style>
    body { margin: 0; background-color: black;}
    circle.source{
      fill: rgba(0,0,0,0);
    }
    circle.pinhole.source{
      fill: green;
    }
    .handle{
      cursor: pointer;
    }
    .handle .nob{
      fill: white;
      opacity: 1;
    }
    .handle circle{
      fill: rgba(0,0,0,0);
      stroke: none;
    }
    .handle circle{
      fill: rgba(0, 0, 0, 0.2);
      stroke: rgba(0, 0, 0, 0.2);
    }
    canvas, svg {
      position: absolute;
    }
  </style>
  <body>
    <script src="d3.js"></script>
    <script src="geo.js"></script>
    <script src="common.js"></script>
    <script>

var canvas = d3.select('body').append('canvas').attr({width: w, height: h})
  , svg = d3.select('body').append('svg').attr({width: w, height: h})
  , ctx = canvas.node().getContext('2d')
  , pos_circle = function(pos){
      return function(circle){ circle.attr({ cx: pos[0], cy: pos[1] }) }
    }
  , trans_str = function(x,y){ return 'translate(' + x + ',' + y + ')' }
  , translate = function(pos){
    return function(g){ g.attr('transform', trans_str.apply(this, pos)) }
  }
  , ray_lives = 10
  , alpha = 0.05
  , targetColors = ['rgb(255,255,255)', 'rgb(255,0,0)', 'rgb(0,255,0)'
    , 'rgb(0,0,255)']
  , color = function(d){
    var c = d3.rgb(targetColors[d % targetColors.length])
    return 'rgba(' + c.r + ',' + c.g + ',' + c.b + ',' + alpha + ')'
  }
  , num_diffuse = 0


// the geometry

var surfaces = [
  {
    geometry: points_line_diffuse([w * 0.8, h * 0.1], [w * 0.8, h * 0.9]
      , w / 2, 100, 10)
    , material: { diffusion: 0, reflection: 1 }
  }
]

// add the light(s)

var sources = d3.range(1).map(function(d){
  return { 
    rays: 10 // number of rays the ligh source will emit
    , rotation: pi * 0
    , spray: pi * 0.1
    , position: [ w * 0.25, h * 0.5]
    , color: 'rgba(255,255,255,0.3)' //color(d + 1)
  }
})

function transform_update(g){
  g.attr('transform', function(d){
    return 'translate(' + d.position[0] + ',' + d.position[1] + ')'
      + ' rotate(' + ( -d.rotation * 180 / pi) + ') '
  })
}

svg.selectAll('g.handle').data(sources).enter().append('g')
  .attr('class', 'handle').call(transform_update).call(function(){
    this.each(function(){ setup_handle(d3.select(this)) })
  })

function setup_handle(handle){
  var datum = handle.datum()
    , g = handle.append('g').attr('class', 'controls')
    , normal_radius = 100
    , radius = normal_radius
    , prev_rays = datum.rays
    , arc = d3.svg.arc()
    , update_outline = function(outline){
        outline.attr('d', arc.innerRadius(radius - 2).outerRadius(radius + 2))
    }
  // add invsibile the position circle
  g.append('circle').attr({r:radius})
    .call(d3.behavior.drag().on("drag", function(){
      datum.position = mouse
      handle.call(transform_update)
    }).on('dragstart', function(){ d3.select(this).classed('active', true)})
    .on('dragend', function(){ d3.select(this).classed('active', false) }))
  // create the outline border
  var outline = g.append('path').datum({ startAngle: pi/2, endAngle: -pi*2 })
    .style('opacity', '0.2').style('fill', 'white').call(update_outline)
  // `spray` and `ray number` nob
  g.append('circle').call(pos_circle(rot([radius, 0], - datum.spray / 2)))
    .attr('r', 5).attr('class', 'nob spray')
    .call(d3.behavior.drag().on('dragstart', function(){
      prev_rays = datum.rays
    }).on('drag', function(){
      var pos = angle_cap(d3.mouse(this), 0, pi)
      datum.spray = angle(pos) * 2
      radius = len(pos)
      update_outline(outline)
      datum.rays = prev_rays + radius - normal_radius
      if(datum.rays < 0) datum.rays = 1
      d3.select(this).call(pos_circle(pos))
      // hide the rotation nob when the sray nob exceeds 359 degrees
      handle.select('.nob.rotation')
        .style('opacity', datum.spray >= 2 * pi ? 0 : 1)
    }).on('dragend', function(){
      prev_radius = radius = normal_radius
      update_outline(outline)
      var pos = scale(unit(angle_cap(d3.mouse(this), 0, pi)), radius)
      d3.select(this).call(pos_circle(pos))
    }))
  // rotation nob
  g.append('circle').call(pos_circle([-radius * 0.5, 0]))
    .attr('r', 10).attr('class', 'nob rotation')
    .call(d3.behavior.drag().on('drag', function(){
      var pos = minus(d3.mouse(svg.node()), datum.position)
      datum.rotation = angle(pos) + pi
      handle.call(transform_update)
    }))
}

// slider
svg.append('g')


ctx.fillStyle = 'black'

// draw loop
d3.timer(function(){
// setInterval(function(){
  // clear the bg
  ctx.globalCompositeOperation = 'source-over'
  ctx.fillRect(0, 0, w, h)
  ctx.globalCompositeOperation = 'lighter'
  
  // draw the surfaces
  ctx.lineWidth = 1
  ctx.strokeStyle = 'green' // color them green
  ctx.beginPath()
  surfaces.forEach(function(surface){
    surface.geometry.forEach(function(segment){
      ctx.moveTo(segment[0][0], segment[0][1])
      ctx.lineTo(segment[1][0], segment[1][1])
    })
  })
  ctx.stroke()

  ctx.lineWidth = 1

  var rays = d3.merge(sources.map(function(source){
    return source_rays(source, ray_lives)
  }))

  rays = ray_trace(surfaces, 20, 2000, rays, num_diffuse)

  // color the rays

  rays.forEach(function(ray){
    // ray.source.color
    ctx.strokeStyle = ray.source.color
    ctx.beginPath()
    ray.values.forEach(function(p, i){
      if(i === 0) ctx.moveTo(Math.round(p[0]) + 0.5, Math.round(p[1]) + 0.5)
      else ctx.lineTo(Math.round(p[0]) + 0.5,Math.round(p[1]) + 0.5)
    })
    ctx.stroke()
  })
}, 500)

    </script>
  </body>
</html>