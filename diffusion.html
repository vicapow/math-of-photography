<!DOCTYPE html>
<meta charset="utf-8">
<html>
  <style>
    body, html{ margin: 0;}
    circle{ fill: blue; }
    path{ stroke: black; stroke-width: 1; fill: none;}
    .eye line, .eye path{
      stroke: black;
      stroke-width: 6;
      fill: none;
    }
    path.ray{
      /*stroke-dasharray: 5, 4;*/
      stroke-width: 1;
      stroke-linejoin: bevel;
      opacity: 1;
      stroke: blue;
    }
    .surface{
      stroke-width: 2;
      stroke: black;
    }

  </style>
  <body>
    <svg></svg>
    <script src="d3.js"></script>
    <script src="vec.js"></script> <!-- small library of vector functions -->
    <script>
var w = window.innerWidth, h = window.innerHeight
  , max = Math.max(w, h), min = Math.min(w, h), pi = Math.PI, abs = Math.abs
  , cos = Math.cos, sin = Math.sin
  , svg = d3.select('svg').attr({width: w, height: h})
  , rand = function(n){ return Math.random() * n }
  , translate = function(x,y){ return 'translate(' + x + ',' + y + ')' }
  , line = d3.svg.line()
  , n = 100, m = 0, num_rays = 1, ray_len = 10000



// surface is an array of line segments of the form: [p1, p2]
// so surface looks like: [ [p1, p2], [p2, p3], ... ]
// where each `p*` is a ponit, described as a 2 element array. ie., [343, 253]
/*
var surface = [
  [ // line segment 1
      [ p1x, p2y ]
    , [ p2x, p2y ]
  ]
  , [ // line segment 2
      [ p2x, p2y ]
    , [ p3x, p3y ]
  ]
  etc...
]
*/

// flat or bumpy surface
var surface = d3.range(n).map(rand.bind(null, m))
  .map(function(d, i){ return [i * w / (n - 1), d + h * 0.5] })
  .map(function(p, i, surface){ 
    if( i === surface.length - 1) return null
    return [ p , surface[i + 1] ]
  }).filter(function(d){ return d })

// flat or bumpy surface
var surface2 = d3.range(n).map(rand.bind(null, m))
  .map(function(d, i){ return [i * w / (n - 1), d + h * 0.55] })
  .map(function(p, i, surface){ 
    if( i === surface.length - 1) return null
    return [ p , surface[i + 1] ]
  }).filter(function(d){ return d })

surface = surface.concat(surface2)


surface = surface.concat(d3.range(n).map(function(d){
  var s = 200, x = w * 0.45, y = h * 0.5
  var spray = 2 * pi, rot = pi * -0.8
  return [ 
    cos(d / (n - 1) * spray + rot) * s + x
    , sin(-d / (n - 1) * spray - rot) * s + y
  ]
}).map(function(p, i, surface){ 
  if( i === surface.length - 1) return null
  return [ p , surface[i + 1] ]
}).filter(function(d){ return d }))

var mouse = [160, 324]
d3.select('body').on('mousemove', function(){ mouse = d3.mouse(this) })

// draw the surface

d3.timer(function(){
  
  svg.selectAll('*').remove()

  svg.append('g').selectAll('line').data(surface).enter()
    .append('line').attr({ 
      'class': 'surface'
      , x1: function(d){ return d[0][0] }
      , y1: function(d){ return d[0][1] }
      , x2: function(d){ return d[1][0] }
      , y2: function(d){ return d[1][1] }
    })

  var source_pos =  mouse.slice(0)

  var source_rays = d3.range(num_rays).map(function(d){
    var spray = 2 * pi, rot = - pi * 0.4
      , theta = spray * (d + 1) / num_rays - spray / 2 - rot
    return [ source_pos, [ cos(theta), sin(theta) ] ]
  })

  var ray_paths = source_rays.map(ray_trace.bind(null, surface))

  svg.append('g').selectAll('path').data(ray_paths)
    .enter().append('path').attr({d: line, 'class': 'ray'})

  var source = svg.append('circle').attr({
    r: 10, cx: source_pos[0], cy: source_pos[1] })
})

    </script>
  </body>
</html>